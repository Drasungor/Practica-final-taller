1) Un constructor por copia es un constructor que recibe otra instancia de un objeto de la clase que se está construyendo, sin modificar esta última. Utiliza la instancia recibida para crear un objeto con los mismos datos que esta. 
	Si el constructor no se encuentra definido por el programador, entonces se define uno por defecto, que realiza una copia bit a bit del objeto recibido en el construido, es decir, cualquier dato presente en el objeto recibido se copia de la misma manera en el construido. Esto es perjudicial si se trabaja con memoria dinámica ya que se copiará también el puntero, generando un doble free cuando se destruyan ambos objetos (o uso de memoria ya liberada, lo cual puede terminar en un segmentation fault). Es por este problema que se define el constructor por copia, alocando más memoria dinámica, en la que se copiará el contenido de la sección de memoria a la que apunta el objeto recibido.
	Para que una clase no sea copiable se puede borrar su constructor por copia de la siguiente manera (suponiendo una clase llamada A):
	A(const A& other) = delete;
	La diferencia principal entre un constructor por copia y uno por movimiento es la modificación del objeto recibido. En el primero este no es modificado, mientras que en el segundo sí lo es. En el constructor por copia se realiza alocación de memoria de ser necesario, mientras que en el constructor por movimiento se saca el/los puntero/s (a memoria dinámica) del objeto recibido y se lo otorga al objeto construido, evitando nuevas alocaciones de memoria. Por último, al utilizar el constructor por copia el objeto recibido permanece intacto, mientras que en el constructor por movimiento el objeto recibido queda en un estado válido pero nulo, ya que le otorgó todos sus datos al objeto construido.

3) 
- void (*F)(int i);: es la declaración de una variable F que es del tipo puntero a una función que recibe un entero y no tiene valor de retorno.
- static void B(float a, float b){}: es la definición de una función B que recibe dos variables de tipo float y no devuelve nada. Esta implementada sin código, por lo que no realiza operaciones al ser llamada.
- int *(*C)[5]; es la declaración de un puntero a un array que contiene 5 punteros a int.

6) Una macro de C es un alias para una porción de texto, esta puede ser un dato o un conjunto de operaciones (que puede recibir o no argumentos). En el momento de precompilacón, se remplaza el texto apropiado en los lugares en los que se haya utilizado la macro, dejando únicamente texto en su lugar (esto es lo que hace las macros "inseguras"). 
	Buenas prácticas para su uso son el encierre de la definición de macro y de cada argumento entre paréntesis, ya que lo único que hace el uso de la macro es remplazar texto. Un ejemplo de errores generados por una mala definición de macros es:
	
#define OPERACION(x, y) x*y+y
int x = OPERACION(1+1, 3) * 5;

Al remplazar el texto, quedará: int x = 1+1*3+3*5 (que resulta ser 19), en vez del deseado int x = ((1+1)*3+3) * 5 (que resulta ser 45)

Una buena definición de la macro, que termina generando el resultado deseado es entonces:

#define OPERACION(x, y) ((x)*(y)+(y))

8) Se conoce como compilación a una serie de operaciones que terminan 

9)

10)


