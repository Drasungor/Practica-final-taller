2) Un functor es una clase que imita en cierta forma el funcionamiento de una función, es decir, una instancia de una clase de tipo functor es usada como si fuera una función. Este tipo de clases tienen únicamente definido el operador () (recibiendo 0 o más argumentos). El objetivo de un functor es la separación de la ejecución de una función del momento en el que esta recibe sus argumentos. Esto permite recibir en un momento los argumentos, guardándolos como atributos de la clase, y llamar luego, cuando sea necesario, el método () para simular la ejecución de una función. Para que un functor sea considerado como tal, solo debe tener definido el constructor y el operador (), sino sería una clase normal. La ventaja que ofrece un functor respecto de una función normal es la ya mencionada separación entre el momento de recibimiento de argumentos y el momento de ejecución de la función, esto permite por ejemplo pasar "funciones" que ya contienen los argumentos con los que ejecutarse a algún iterador que la utilice.

4)
- a; :es un entero de una variable estática, es decir, es una variable almacenada en el data segment, y su memoria es reservada al inicio del programa. Esta variable nunca es modificada, por lo que el valor que contiene es la basura que hubiese en la sección de memoria que se le asignó (algunos sistemas operativos inicializan las variables con valores default como 0, pero como no se habla de alguno en específico se debe asumir que esto no pasa). Al ser global, puede ser accedida desde cualquier parte del módulo (no desde otro módulo ya que el que sea estática no lo permite).

- b: es una función que no recibe argumentos y retorna un entero, su definición se encuentra almacenada en el code segment. Esta función retorna la suma entre los valores que almacenan c y d.

- c: es una variable estática del tipo int, por lo que se le asigna memoria al comienzo del programa y se encuentra en el data segment. Al igual que "a", como no es inicializada contiene la basura que contenga el espacio de memoria que se le fue asignado. Es una variable local a b, por lo que solo puede ser modificada dentro de b, pero como la variable se encuentra en el data segment cualquier modificación a c permanecerá luego de que termine la ejecución de b (esto no pasa en el programa del ejercicio ya qye no se modifica c, pero si se modificara es lo que pasaría).

- d: es una variable de tipo char que es local a b, y se encuentra almacenada en el stack segment, es inicializada justo después de ser declarada, como el valor asignado no se modifica a lo largo de la ejecución de b, en todo momento almacena el valor 65.

6) Los templates se publican con todo el codigo fuente ya que deben ser compilados para el tipo de dato con el que se utilicen para poder operar correctamente sobre ellos, ya que para poder hacer esto se debe saber el tamaño del dato con el que se va a operar. Esto se debe a que para que el programa debe saber el tamaño de los datos con los que opera ya que sino le es imposible realizar operaciones como avanzar una posición en un array de datos de ese tipo, pasar una copia de un dato de ese tipo, etc.

10) La diferencia principal entre un constructor por copia y uno por movimiento es la modificación del objeto que se usa para construir el otro objeto. Supobiendo un objeto A que está siendo construido usando un objetoo B de la misma clase, el constructor por copia no modificaría los contenidos del objeto B, mientras que utilizando el constructor por movimiento se pasarían los datos de B a A, dejando B en un estado válido pero nulo. Se diferencian también en la rapidez de los constructores, ya que en el constructor por copia se debe alocar memoria dinámica si la clase almacena un puntero a ese tipo de memoria, mientras que el constructor por movimiento se lo quita a B y se lo otorga a A, eliminando así le pedido de memoria.
